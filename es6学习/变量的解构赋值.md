# 变量的的解构赋值

## 基本用法

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

-   事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。
-   对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

```text
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined
```

> 上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。

---

## 默认值

解构赋值允许指定默认值。

## 注意点

```text
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
```

上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。

```text
// 正确的写法
let x;
({x} = {x: 1});
```

由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。

```text
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
```

---

-   字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
-   数值和布尔值的解构赋值
    解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。

> 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。

---

## 圆括号问题

建议只要有可能，就不要在模式中放置圆括号。

### 不能使用圆括号的情况

1.变量声明语句

```text
// 全部报错
let [(a)] = [1];
let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};
let { o: ({ p: p }) } = { o: { p: 2 } };
```

2.函数参数

```text
// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
```

3.赋值语句的模式

```text
// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];
```

### 可以使用圆括号的情况

可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。

```text
[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
```

---

## 用途

-   交换变量的值
-   从函数返回多个值
-   函数参数的定义
-   提取 JSON 数据
-   函数参数的默认值
-   遍历 Map 结构
-   输入模块的指定方法
